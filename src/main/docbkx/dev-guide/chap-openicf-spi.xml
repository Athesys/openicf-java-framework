<?xml version="1.0" encoding="UTF-8"?>
<!--
  ! CCPL HEADER START
  !
  ! This work is licensed under the Creative Commons
  ! Attribution-NonCommercial-NoDerivs 3.0 Unported License.
  ! To view a copy of this license, visit
  ! http://creativecommons.org/licenses/by-nc-nd/3.0/
  ! or send a letter to Creative Commons, 444 Castro Street,
  ! Suite 900, Mountain View, California, 94041, USA.
  !
  ! You can also obtain a copy of the license at
  ! legal-notices/CC-BY-NC-ND.txt.
  ! See the License for the specific language governing permissions
  ! and limitations under the License.
  !
  ! If applicable, add the following below this CCPL HEADER, with the fields
  ! enclosed by brackets "[]" replaced with your own identifying information:
  !      Portions Copyright [yyyy] [name of copyright owner]
  !
  ! CCPL HEADER END
  !
  !      Copyright 2014-2015 ForgeRock AS
  !
-->
<chapter xml:id='chap-openicf-spi'
 xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en'
 xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
 xsi:schemaLocation='http://docbook.org/ns/docbook
 http://docbook.org/xml/5.0/xsd/docbook.xsd'
 xmlns:xlink='http://www.w3.org/1999/xlink'>

 <title>Implementing the OpenICF SPI</title>
 <para>
  This chapter describes the OpenICF SPI, which enables you to create connectors
  that are compatible with the OpenICF framework.
 </para>
 <para>
  The SPI includes a number of interfaces, but you need only implement those
  that are supported by the target resource to which you are connecting. For
  information about how to get started with writing connectors, see
  <link xlink:show="new" xlink:href="dev-guide#chap-java-connectors"
  xlink:role="http://docbook.org/xlink/role/olink"><citetitle>Writing Java
  Connectors</citetitle></link> and <link xlink:show="new"
  xlink:href="dev-guide#chap-groovy-connectors"
  xlink:role="http://docbook.org/xlink/role/olink"><citetitle>Writing Scripted
  Connectors With the Groovy Connector Toolkit</citetitle></link>.
 </para>

 <section xml:id="connector-types">
  <title>Deciding on the Connector Type</title>
  <para>
   OpenICF supports multiple connector types, based on the implementation of the
   <literal>connector</literal> interface, and the
   <literal>configuration</literal> interface. These two interfaces determine
   whether the connector can be pooled, and whether its configuration is
   stateful. Before you begin developing your connector, decide on the
   <emphasis>connector type</emphasis>, based on the system to which you are
   connecting. This section outlines the different connector types.
  </para>
  <variablelist>
   <varlistentry>
    <term>Connector</term>
    <listitem>
     <para>
      The basic connector is a <emphasis>non-poolable</emphasis> connector. Each
      operation is executed on a new instance of the connector. OpenICF creates
      a new instance of the Connector class and uses a new or existing instance
      of the connector configuration to initialise the instance before the
      operation is executed. After the execution, OpenICF disposes of the
      connector instance.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Poolable Connector</term>
    <listitem>
     <para>
      Before an operation is executed, an existing connector instance is pulled
      from the Connector Pool. If there is no existing instance, a new instance
      is created. After the operation execution, the Connector instance is
      released and placed back into pool.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Configuration</term>
    <listitem>
     <para>
      For a basic (non-stateful) configuration, each time the configuration is
      used (when an operation is validated or a new connector instance is
      initialised, a new Configuration instance is created and configured with
      the Configuration properties.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Stateful Configuration</term>
    <listitem>
     <para>
      With a stateful configuration, the configuration instance is created only
      once and is used until the Facade or Connector Pool that is associated
      with the Configuration is disposed of.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
  <para>
   The following table illustrates how these elements combine to determine the
   connector type.
  </para>
  <table frame="all">
   <title>Connector Types</title>
   <tgroup cols="3">
    <colspec colname="c1" colnum="1" colwidth="1.0*"/>
    <colspec colname="c2" colnum="2" colwidth="1.0*"/>
    <colspec colname="c3" colnum="3" colwidth="1.0*"/>
    <thead>
     <row>
      <entry/>
      <entry>Connector</entry>
      <entry>Poolable Connector</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><emphasis role="strong">Configuration</emphasis></entry>
      <entry>
       Entirely stateless combination. A new Configuration and Connector
       instance are created for each operation.
      </entry>
      <entry>
       Connector initialisation is an expensive operation, so it is preferable
       to keep connector instances in a pool. A new configuration is required
       only when a new connector instance is added to the pool.
      </entry>
     </row>
     <row>
      <entry><emphasis role="strong">Stateful Configuration</emphasis></entry>
      <entry>
       The configuration can be used to make the heavy resource initialisation.
       The less intensive connector instance can then execute the operation.
      </entry>
      <entry>
       The configuration must be shared between the instances in the same pool
       and the connector initialisation is expensive.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </section>

 <section xml:id="connector-implementation">
  <title>Implementing the Connector Interface</title>
  <para>
   This is the main interface to declare a connector, and to manage its life
   cycle. The <literal>connector</literal> interface <emphasis>must</emphasis>
   be implemented. A typical connector lifecycle is as follows:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     The connector creates a connection to the target system.
    </para>
   </listitem>
   <listitem>
    <para>
     Any operations implemented in the connector are called.
    </para>
   </listitem>
   <listitem>
    <para>
     The connector discards the connection and disposes of any resources it has
     used.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   The <literal>connector</literal> interface has only three methods:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     <literal>init(Configuration)</literal> initializes the connector with its
     configuration
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>getConfiguration()</literal> returns the configuration that was
     passed to <literal>init(Configuration)</literal>
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>dispose()</literal> disposes of any resources that the connector
     uses.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   Both the <literal>init(Configuration)</literal> and
   <literal>dispose()</literal> methods permit block operations (which enable
   bulk creates or deletes) and the use of <literal>before</literal> and
   <literal>after</literal> actions.
  </para>
  <para>
   The <literal>PoolableConnector</literal> extends this interface with the
   <literal>checkAlive()</literal> method. You should use a
   <literal>PoolableConnector</literal> when the
   <literal>init(Configuration)</literal> method is so expensive that it is
   worth keeping the connector instance in a pool and reusing it between
   operations. When an existing connector instance is pooled, the framework
   calls the <literal>checkAlive()</literal> method. If it throws an error, the
   framework disposes it from the pool and obtains another one, or creates a
   new connector instance and calls the <literal>init()</literal> method. The
   <literal>checkAlive()</literal> method is used to make sure that the
   instance in the pool is still operational.
  </para>
 </section>

 <section xml:id='configuration-implementation'>
  <title>Implementing the Configuration Interface</title>
  <para>
   The configuration interface implementation includes all of the required
   information to enable the connector to connect to the target system, and to
   perform its operations. The configuration interface implements getters and
   setters for each of its defined properties. It also provides a validate
   method that determines whether all the required properties are available, and
   valid, before passing them to the connector.
  </para>
  <para>
   The configuration interface has three methods:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     <literal>setConnectorMessages(ConnectorMessages messages)</literal> sets
     the message catalog instance that allows the connector to localize
     messages.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>getConnectorMessages()</literal> returns the message catalog that
     is set by setConnectorMessages(ConnectorMessages)
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>validate()</literal> checks that all the required properties have
     been set and that their values are valid
    </para>
   </listitem>
  </itemizedlist>
  <para>
   Each property that is declared is not necessarily required. If a property is
   required, it must be included in the <literal>ConfigurationProperty</literal>
   annotation.
  </para>
  <para>
   The configuration interface is traversed through reflection. The
   <literal>ConfigurationProperty</literal> annotation provides a way to
   override the default configuration operation for each property. The
   annotation includes the following elements:
  </para>
  <informaltable>
   <tgroup cols="4">
    <thead>
     <row>
      <entry>Element</entry>
      <entry>Description</entry>
      <entry>Implementation in Java</entry>
      <entry>Implementation in C#</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>order</entry>
      <entry>The order in which this property is displayed</entry>
      <entry> </entry>
      <entry> </entry>
     </row>
     <row>
      <entry>helpMessageKey</entry>
      <entry>Enables you to change the default help message key</entry>
      <entry><literal><replaceable>propertyName</replaceable>.help</literal></entry>
      <entry><literal><replaceable>help_propertyName</replaceable></literal></entry>
     </row>
     <row>
      <entry>displayMessageKey</entry>
      <entry>Enables you to change the default display message key</entry>
      <entry><replaceable>propertyName.display</replaceable></entry>
      <entry><replaceable>display_propertyName</replaceable></entry>
     </row>
     <row>
      <entry>groupMessageKey</entry>
      <entry>Enables you to change the default group message key</entry>
      <entry><replaceable>propertyName.group</replaceable></entry>
      <entry><replaceable>group_propertyName</replaceable></entry>
     </row>
     <row>
      <entry>confidential</entry>
      <entry>Indicates that this is a confidential property and that its value
       should be encrypted by the application when persisted</entry>
      <entry> </entry>
      <entry> </entry>
     </row>
     <row>
      <entry>required</entry>
      <entry>Boolean, indicates whether the property is required</entry>
      <entry> </entry>
      <entry> </entry>
     </row>
     <row>
      <entry>operations</entry>
      <entry>The array of operations that require this property</entry>
      <entry> </entry>
      <entry> </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>

  <example xml:id='configuration-java-implementation'>
   <title>Configuration Implementation in Java</title>
   <programlisting language="java">
public class SampleConfiguration extends AbstractConfiguration  {

    /**
     * {@inheritDoc}
     */
    public void validate() {
    }

    @ConfigurationProperty(
        order = 1,
        helpMessageKey = "passwordFieldName.help",
        displayMessageKey = "passwordFieldName.display",
        groupMessageKey = "authenticateOp.group",
        confidential = false,
        required = false,
        operations = AuthenticateOp.class
    )
    public String getPasswordFieldName() {
        return passwordFieldName;
    }

    public void setPasswordFieldName(String value) {
        passwordFieldName = value;
    }
}  </programlisting>

   <programlisting language="java">
public class SampleConfiguration extends AbstractConfiguration
    implements StatefulConfiguration {

    /**
     * {@inheritDoc}
     */
    public void release() {
    }

    /**
     * {@inheritDoc}
     */
    public void validate() {
    }
}  </programlisting>
  </example>

  <example xml:id='configuration-csharp-implementation'>
   <title>Configuration Implementation in C#</title>
   <programlisting language="csharp">
public class ActiveDirectoryConfiguration : AbstractConfiguration
    {

        [ConfigurationProperty(
            Order = 1,
            HelpMessageKey = "help_PasswordFieldName",
            DisplayMessageKey = "display_PasswordFieldName",
            GroupMessageKey = "group_PasswordFieldName",
            Confidential = false,
            Required = false,
            OperationTypes = new[] { typeof(AuthenticateOp) })
        ]
        public String PasswordFieldName
        { get; set; }

        public override void Validate()
        {
            throw new NotImplementedException();
        }
    }
   </programlisting>

   <programlisting language="csharp">
public class ActiveDirectoryConfiguration : AbstractConfiguration,
    StatefulConfiguration
    {

        public override void Validate()
        {
            throw new NotImplementedException();
        }

        public void Release()
        {
            throw new NotImplementedException();
        }
    }
    </programlisting>
   </example>

   <section xml:id='AbstractConfiguration-spi-level-rules'>
    <title>Configuration Implementation Rules</title>
    <para>
     The <literal>validate()</literal> method of the configuration operation
     must return one of the following:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>RuntimeException</literal> if the configuration is not valid
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>NullPointerException</literal> if a required configuration
       property is null
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>IllegalArgumentException</literal> if a required configuration
       property is blank
      </para>
     </listitem>
    </itemizedlist>
    <example>
     <title>Implementation of the validate method</title>
     <programlisting language="java">public void validate() {
    if (StringUtil.isBlank(host)) {
        throw new IllegalArgumentException("Host User cannot be null or empty.");
    }

    Assertions.blankCheck(remoteUser, "remoteUser");

    Assertions.nullCheck(password, "password");
}</programlisting>
    </example>
   </section>

   <section xml:id='configuration-properties-implementation'>
    <title>Supported Configuration Types</title>
    <para>
     The OpenICF framework supports a limited number of configuration property
     types. This limitation is necessary, because OpenICF must serialise and
     deserialize the configuration property values when sending them over the
     network.
    </para>
    <para>
     You can use any of the following types, or an array of these types. Lists
     sets of types are not supported.
    </para>
    <screen>
    String.class
    long.class
    Long.class
    char.class
    Character.class
    double.class
    Double.class
    float.class
    Float.class
    int.class
    Integer.class
    boolean.class
    Boolean.class
    URI.class
    File.class
    GuardedByteArray.class
    GuardedString.class
    Script.class
    </screen>
    <screen>
    typeof(string),
    typeof(long),
    typeof(long?),
    typeof(char),
    typeof(char?),
    typeof(double),
    typeof(double?),
    typeof(float),
    typeof(float?),
    typeof(int),
    typeof(int?),
    typeof(bool),
    typeof(bool?),
    typeof(Uri),
    typeof(FileName),
    typeof(GuardedByteArray),
    typeof(GuardedString),
    typeof(Script)
    </screen>
    <para>
     The framework introspects the Configuration class and adds all properties
     that have a <literal>set/get</literal> method to the configuration
     properties. If the type of an added property is not supported, the
     framework throws an exception. If you want to avoid the exception (and
     simply ignore all unsupported types) use the following construction:
    </para>
    <para>
     In Java:
    </para>
    <programlisting language="java">
@ConfigurationClass(ignore = { "privateProperty", "internalProperty" }, skipUnsupported = true)    </programlisting>
    <para>
     In C#:
    </para>
    <programlisting language="csharp">
[ConfigurationClass(Ignore = { "privateProperty", "internalProperty" }, SkipUnsupported = true)]    </programlisting>
   </section>
 </section>

 <section xml:id="operation-implementation">
  <title>Implementing the Operation Interfaces</title>
  <para>
   The SPI provides several operations. The subset of operations that you
   implement will depend on the target resource to which you are connecting.
   Each operation interface defines an action that the connector can perform on
   the target resource.
  </para>
  <para>
   The following sections describe the operation interfaces that are provided by
   the SPI, and provide examples of how they can be implemented in your
   connector. The sections include the API- and SPI-level rules for each
   operation.
  </para>

  <section xml:id='operation-authenticate'>
   <title>Authenticate Operation</title>
   <para>
    The authenticate operation authenticates an object on the target system,
    based on two parameters, usually a unique identifier (username) and
    password. If possible, your connector should try to authenticate these
    credentials natively.
   </para>
   <para>
    If authentication fails, the connector should throw a runtime
    exception, either an <literal>IllegalArgumentException</literal> or, if a
    native exception is available and is of type
    <literal>RuntimeException</literal>, simply throw that exception. If the
    native exception is not a <literal>RuntimeException</literal>, it should be
    wrapped in a <literal>RuntimeException</literal>, and then thrown.
   </para>
   <para>
    The exception should provide as much detail as possible for logging problems
    and failed authentication attempts. Several exceptions are provided in the
    <literal>exceptions</literal> package, for this purpose. For example, one of
    the most common authentication exceptions is the
    <literal>InvalidPasswordException</literal>.
   </para>

   <section xml:id='AuthenticationApiOp-api-level-rules'>
    <title>AuthenticationApiOp</title>
    <para>
     API-level rules:
    </para>
    <para>
     The operation throws a <literal>RuntimeException</literal> if the
     credentials do not pass authentication, otherwise throws nothing.
    </para>
    <example>
     <title>Implementation of the Authentication Operation, at the API Level</title>
<programlisting language="java">@Test
public void authenticateTest() {
    logger.info("Running Authentication Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    Uid uid =
            facade.authenticate(ObjectClass.ACCOUNT, "username", new GuardedString("Passw0rd"
                    .toCharArray()), builder.build());
    Assert.assertEquals(uid.getUidValue(), "username");
}</programlisting>
    </example>
   </section>

   <section xml:id='AuthenticateOp-spi-level-rules'>
    <title>AuthenticateOp</title>
    <para>
     The SPI provides the following detailed exceptions:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       UnknownUidException - the UID does not exist on the resource
      </para>
      <para>
       <literal>(org.identityconnectors.framework.common.exceptions.UnknownUidException)</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       ConnectorSecurityException - base exception for all security-related
       exceptions
      </para>
      <para>
       <literal>(org.identityconnectors.framework.common.exceptions.ConnectorSecurityException)</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       InvalidCredentialException - generic invalid credential exception that
       should be used if the specific error cannot be obtained
      </para>
      <para>
       <literal>(org.identityconnectors.framework.common.exceptions.UnknownUidException)</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       InvalidPasswordException - the password provided is incorrect
      </para>
      <para>
       <literal>(org.identityconnectors.framework.common.exceptions.InvalidPasswordException)</literal>
      </para>
     </listitem>
     <listitem>
      <para>
      PasswordExpiredException - the password is correct, but has expired
      </para>
      <para>
       <literal>(org.identityconnectors.framework.common.exceptions.PasswordExpiredException)</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       PermissionDeniedException - the user can be identified but does not have
       permission to authenticate
      </para>
      <para>
       <literal>(org.identityconnectors.framework.common.exceptions.PermissionDeniedException)</literal>
      </para>
     </listitem>
    </itemizedlist>
    <example>
     <title>Implementation of the Authentication Operation, at the SPI Level</title>
     <programlisting language="java">public Uid authenticate(final ObjectClass objectClass, final String userName,
        final GuardedString password, final OperationOptions options) {
    if (ObjectClass.ACCOUNT.equals(objectClass)) {
        return new Uid(userName);
    } else {
        logger.warn("Authenticate of type {0} is not supported", configuration
                .getConnectorMessages().format(objectClass.getDisplayNameKey(),
                        objectClass.getObjectClassValue()));
        throw new UnsupportedOperationException("Authenticate of type"
                + objectClass.getObjectClassValue() + " is not supported");
    }
}</programlisting>
    </example>
   </section>
  </section>

  <section xml:id='operation-create'>
   <title>Create Operation</title>
   <para>
    The create operation interface enables the connector to create objects on
    the target system. The operation includes one method
    (<literal>create()</literal>). The method takes an
    <literal>ObjectClass</literal>, and any provided attributes, and creates the
    object and its Uid. The connector must return the Uid so that the caller can
    refer to the created object.
   </para>
   <para>
    The connector should make a best effort to create the object, and should
    throw an informative <literal>RuntimeException</literal>, indicating to the
    caller why the operation could not be completed. Defaults can be used for
    any required attributes, as long as the defaults are documented.
   </para>
   <para>
    The Uid is never passed in with the attribute set for this method. If the
    resource supports a mutable Uid, you can create a resource-specific
    attribute for the ID, such as <literal>unix_uid</literal>.
   </para>

   <section xml:id='CreateApiOp-api-level-rules'>
    <title>CreateApiOp</title>
    <para>
     The following exceptions are thrown by the Create API operation:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>IllegalArgumentException</literal> - if
       <literal>ObjectClass}</literal> is missing, or if elements of the
       set produce duplicate values of <literal>Attribute#getName()</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>NullPointerException</literal> - if the
       <code>createAttributes</code> parameter is <literal>null</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>RuntimeException</literal> - if the
       <literal>Connector</literal> SPI throws a native exception
      </para>
     </listitem>
    </itemizedlist>
    <example>
     <title>Implementation of the Create Operation, at the API Level</title>
     <programlisting language="java">@Test
public void createTest() {
    logger.info("Running Create Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    Set&lt;Attribute> createAttributes = new HashSet&lt;Attribute>();
    createAttributes.add(new Name("Foo"));
    createAttributes.add(AttributeBuilder.buildPassword("Password".toCharArray()));
    createAttributes.add(AttributeBuilder.buildEnabled(true));
    Uid uid = facade.create(ObjectClass.ACCOUNT, createAttributes, builder.build());
    Assert.assertEquals(uid.getUidValue(), "foo");
}</programlisting>
    </example>
   </section>

   <section xml:id='CreateOp-spi-level-rules'>
    <title>CreateOp</title>
    <para>
     The SPI provides the following detailed exceptions:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>UnsupportedOperationException</literal> - the create operation
       is not supported for the specified object class
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>InvalidAttributeValueException</literal> - a required attribute
       is missing, an attribute is present that cannot be created, or a provided
       attribute has an invalid value
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>AlreadyExistsException</literal> - an object with the specified
       <literal>Name</literal> already exits on the target system
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>PermissionDeniedException</literal> - the target resource will
       not allow the connector to perform the specified operation
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>ConnectorIOException, ConnectionBrokenException,
        ConnectionFailedException</literal> - a problem as occurred with the
        connection
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>RuntimeException</literal> - thrown if anything else goes wrong.
       You should try to throw a native exception in this case.
      </para>
     </listitem>
    </itemizedlist>
    <example>
     <title>Implementation of the Create Operation, at the API Level</title>
     <programlisting language="java">public Uid create(final ObjectClass objectClass, final Set&lt;Attribute> createAttributes,
        final OperationOptions options) {
    if (ObjectClass.ACCOUNT.equals(objectClass) || ObjectClass.GROUP.equals(objectClass)) {
        Name name = AttributeUtil.getNameFromAttributes(createAttributes);
        if (name != null) {
            // do real create here
            return new Uid(AttributeUtil.getStringValue(name).toLowerCase());
        } else {
            throw new InvalidAttributeValueException("Name attribute is required");
        }
    } else {
        logger.warn("Delete of type {0} is not supported", configuration.getConnectorMessages()
                .format(objectClass.getDisplayNameKey(), objectClass.getObjectClassValue()));
        throw new UnsupportedOperationException("Delete of type"
                + objectClass.getObjectClassValue() + " is not supported");
    }
}</programlisting>
    </example>
   </section>
  </section>

  <section xml:id='operation-delete'>
   <title>Delete Operation</title>
   <para>
    The delete operation interface enables the connector to delete an object on
    the target system. The operation includes one method
    (<literal>delete()</literal>). The method takes an
    <literal>ObjectClass</literal>, a <literal>Uid</literal>, and any operation
    options.
   </para>
   <para>
    The connector should call the native delete methods to remove the object,
    specified by its unique ID.
   </para>

   <section xml:id='DeleteApiOp-api-level-rules'>
    <title>DeleteApiOp</title>
    <para>
     The following exceptions are thrown by the Delete API operation:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>UnknownUidException</literal> - the Uid does not exist on the
       resource
      </para>
     </listitem>
    </itemizedlist>
    <example>
     <title>Implementation of the Delete Operation, at the API Level</title>
     <programlisting language="java">@Test
public void deleteTest() {
    logger.info("Running Delete Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    facade.delete(ObjectClass.ACCOUNT, new Uid("username"), builder.build());
}</programlisting>
    </example>
   </section>

   <section xml:id='DeleteOp-spi-level-rules'>
    <title>DeleteOp</title>
    <example>
     <title>Implementation of the Delete Operation, at the SPI Level</title>
     <programlisting language="java">public void delete(final ObjectClass objectClass, final Uid uid, final OperationOptions options) {
    if (ObjectClass.ACCOUNT.equals(objectClass) || ObjectClass.GROUP.equals(objectClass)) {
        // do real delete here
    } else {
        logger.warn("Delete of type {0} is not supported", configuration.getConnectorMessages()
                .format(objectClass.getDisplayNameKey(), objectClass.getObjectClassValue()));
        throw new UnsupportedOperationException("Delete of type"
                + objectClass.getObjectClassValue() + " is not supported");
    }
}</programlisting>
    </example>
   </section>
  </section>

  <section xml:id='operation-resolve-username'>
   <title>Resolve Username Operation</title>
   <para>
    The resolve username operation enables the connector to resolve an object to
    its Uid, based on its username. This operation is similar to the simple
    authentication operation. However, the resolve username operation does not
    include a password parameter, and does not attempt to authenticate the
    credentials. Instead, it returns the Uid that corresponds to the supplied
    username.
   </para>
   <para>
    The implementation must, however, validate the username (that is, the
    connector must throw an exception if the username does not correspond to an
    existing object). If the username validation fails, the the connector should
    throw a runtime exception, either an
    <literal>IllegalArgumentException</literal> or, if a native exception is
    available and is of type <literal>RuntimeException</literal>, simply throw
    that exception. If the native exception is not a
    <literal>RuntimeException</literal>, it should be wrapped in a
    <literal>RuntimeException</literal>, and then thrown.
   </para>
   <para>
    The exception should provide as much detail as possible for logging problems
    and failed attempts. Several exceptions are provided in the
    <literal>exceptions</literal> package, for this purpose. For example, one of
    the most common exceptions is the <literal>UnknownUidException</literal>.
   </para>

   <section xml:id='ResolveUsernameApiOp-api-level-rules'>
    <title>ResolveUsernameApiOp</title>
    <para>
     API-level rules:
    </para>
    <para>
     The operation throws a <literal>RuntimeException</literal> if the
     username validation fails, otherwise throws nothing.
    </para>
    <example>
     <title>Implementation of the ResolveUsername operation, at the API Level</title>
     <programlisting language="java">@Test
public void resolveUsernameTest() {
    logger.info("Running ResolveUsername Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    Uid uid = facade.resolveUsername(ObjectClass.ACCOUNT, "username", builder.build());
    Assert.assertEquals(uid.getUidValue(), "username");
}</programlisting>
    </example>
   </section>

   <section xml:id='ResolveUsernameOp-spi-level-rules'>
    <title>ResolveUsernameOp</title>
    <para>
     The SPI provides the following detailed exceptions:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       UnknownUidException - the UID does not exist on the resource
      </para>
     </listitem>
    </itemizedlist>
    <example>
     <title>Implementation of the ResolveUsername Operation, at the SPI Level</title>
     <programlisting language="java">public Uid resolveUsername(final ObjectClass objectClass, final String userName,
        final OperationOptions options) {
    if (ObjectClass.ACCOUNT.equals(objectClass)) {
        return new Uid(userName);
    } else {
        logger.warn("ResolveUsername of type {0} is not supported", configuration
                .getConnectorMessages().format(objectClass.getDisplayNameKey(),
                        objectClass.getObjectClassValue()));
        throw new UnsupportedOperationException("ResolveUsername of type"
                + objectClass.getObjectClassValue() + " is not supported");
    }
}</programlisting>
    </example>
   </section>
  </section>

  <section xml:id='operation-schema'>
   <title>Schema Operation</title>
   <para>
    The Schema Operation interface enables the connector to describe the types
    of objects that it can handle on the target system, and the operations and
    options that the connector supports for each object type.
   </para>
   <para>
    The operation has one method, <literal>schema()</literal>, which returns
    the types of objects on the target system that the connector supports. The
    method should return the object class name, its description, and a set of
    attribute definitions.
   </para>
   <para>
    The implementation of this operation includes a mapping between the native
    object class and the corresponding connector object. The special
    <literal>Uid</literal> attribute should not be returned, because it is not a
    true attribute of the object, but a reference to it. If your resource
    object class has a writable unique ID attribute that is different to its
    <literal>Name</literal>, your schema should contain a resource-specific
    attribute that represents this unique ID. For example, a Unix account object
    might contain a <literal>unix_uid</literal>.
   </para>

   <section xml:id='SchemaApiOp-api-level-rules'>
    <title>SchemaApiOp</title>
    <example>
     <title>Implementation of the SchemaOp operation, at the API Level</title>
     <programlisting language="java">@Test
public void schemaTest() {
    logger.info("Running Schema Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    Schema schema = facade.schema();
    Assert.assertNotNull(schema.findObjectClassInfo(ObjectClass.ACCOUNT_NAME));
}</programlisting>
    </example>
   </section>

   <section xml:id='SchemaOp-spi-level-rules'>
    <title>SchemaOp</title>
    <example>
     <title>Implementation of the SchemaOp operation, at the SPI Level</title>
     <programlisting language="java">public Schema schema() {
    if (null == schema) {
        final SchemaBuilder builder = new SchemaBuilder(BasicConnector.class);
        // Account
        ObjectClassInfoBuilder accountInfoBuilder = new ObjectClassInfoBuilder();
        accountInfoBuilder.addAttributeInfo(Name.INFO);
        accountInfoBuilder.addAttributeInfo(OperationalAttributeInfos.PASSWORD);
        accountInfoBuilder.addAttributeInfo(PredefinedAttributeInfos.GROUPS);
        accountInfoBuilder.addAttributeInfo(AttributeInfoBuilder.build("firstName"));
        accountInfoBuilder.addAttributeInfo(AttributeInfoBuilder.define("lastName")
                .setRequired(true).build());
        builder.defineObjectClass(accountInfoBuilder.build());

        // Group
        ObjectClassInfoBuilder groupInfoBuilder = new ObjectClassInfoBuilder();
        groupInfoBuilder.setType(ObjectClass.GROUP_NAME);
        groupInfoBuilder.addAttributeInfo(Name.INFO);
        groupInfoBuilder.addAttributeInfo(PredefinedAttributeInfos.DESCRIPTION);
        groupInfoBuilder.addAttributeInfo(AttributeInfoBuilder.define("members").setCreatable(
                false).setUpdateable(false).setMultiValued(true).build());

        // Only the CRUD operations
        builder.defineObjectClass(groupInfoBuilder.build(), CreateOp.class, SearchOp.class,
                UpdateOp.class, DeleteOp.class);

        // Operation Options
        builder.defineOperationOption(OperationOptionInfoBuilder.buildAttributesToGet(),
                SearchOp.class);

        // Support paged Search
        builder.defineOperationOption(OperationOptionInfoBuilder.buildPageSize(),
                SearchOp.class);
        builder.defineOperationOption(OperationOptionInfoBuilder.buildPagedResultsCookie(),
                SearchOp.class);

        // Support to execute operation with provided credentials
        builder.defineOperationOption(OperationOptionInfoBuilder.buildRunWithUser());
        builder.defineOperationOption(OperationOptionInfoBuilder.buildRunWithPassword());

        schema = builder.build();
    }
    return schema;
}</programlisting>
    </example>
   </section>
  </section>

  <section xml:id='operation-script-on-connector'>
   <title>Script On Connector Operation</title>
   <para>
    The script on connector operation runs a script in the environment of the
    connector. This is different to the script on resource operation, which runs
    a script on the target resource that the connector manages.
   </para>
   <para>
    The corresponding API operation (<literal>scriptOnConnectorApiOp</literal>)
    provides a minimum contract to which the connector must adhere. (See the
    <link
    xlink:href="http://openicf.forgerock.org/apidocs/org/identityconnectors/framework/api/operations/ScriptOnConnectorApiOp.html">javadoc</link>
    for more information). If you intend your connector to provide more
    to the script than what is required by this minimum contract, you must
    implement the <literal>scriptOnConnectorOp</literal> interface.
   </para>

   <section xml:id='ScriptOnConnectorApiOp-api-level-rules'>
    <title>ScriptOnConnectorApiOp</title>
    <para>
     The API operation allows an application to run a script in the context of
     any connector.
    </para>
    <para>
     This operation runs the script in the same JVM or .Net Runtime as the
     connector. That is, if you are using a local framework, the script runs in
     your JVM. If you are connected to a remote framework, the script runs in
     the remote JVM or .Net Runtime.
    </para>
    <example>
     <title>Implementation of the ScriptOnConnector operation, at the API Level</title>
     <programlisting language="java">@Test
public void runScriptOnConnectorTest() {
    logger.info("Running RunScriptOnConnector Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    builder.setRunAsUser("admin");
    builder.setRunWithPassword(new GuardedString("Passw0rd".toCharArray()));

    final ScriptContextBuilder scriptBuilder =
            new ScriptContextBuilder("Groovy", "return argument");
    scriptBuilder.addScriptArgument("argument", "value");

    Object result = facade.runScriptOnConnector(scriptBuilder.build(), builder.build());
    Assert.assertEquals(result, "value");
}    </programlisting>
    </example>
   </section>

   <section xml:id='ScriptOnConnectorOp-spi-level-rules'>
    <title>ScriptOnConnectorOp</title>
    <para>
     The <literal>scriptOnConnector</literal> SPI operation takes the following
     parameters:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>request</literal> - the script and the arguments to be run
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>options</literal> - additional options that control how the
       script is run
      </para>
     </listitem>
    </itemizedlist>
    <para>
     The operation returns the result of the script. The return type must be a
     type that the framework supports for serialization. See the <link
     xlink:href="http://openicf.forgerock.org/apidocs/org/identityconnectors/framework/common/serializer/ObjectSerializerFactory.html">ObjectSerializerFactory</link>
     javadoc for a list of supported return types.
    </para>
    <example>
     <title>Implementation of the ScriptOnConnector operation, at the SPI Level</title>
     <programlisting language="java">public Object runScriptOnConnector(ScriptContext request, OperationOptions options) {
    final ScriptExecutorFactory factory =
            ScriptExecutorFactory.newInstance(request.getScriptLanguage());
    final ScriptExecutor executor =
            factory.newScriptExecutor(getClass().getClassLoader(), request.getScriptText(),
                    true);

    if (StringUtil.isNotBlank(options.getRunAsUser())) {
        String password = SecurityUtil.decrypt(options.getRunWithPassword());
        // Use these to execute the script with these credentials
    }
    try {
        return executor.execute(request.getScriptArguments());
    } catch (Throwable e) {
        logger.warn(e, "Failed to execute Script");
        throw ConnectorException.wrap(e);
    }
}    </programlisting>
    </example>
   </section>
  </section>

  <section xml:id='operation-script-on-resource'>
   <title>Script On Resource Operation</title>
   <para>
    The script on resource operation runs a script directly on the target
    resource (unlike the <xref linkend="operation-script-on-connector" />,
    which runs a script in the context of a specific connector.)
   </para>
   <para>
    Implement this interface if your connector intends to support the
    <literal>ScriptOnResourceApiOp</literal> API operation. If your connector
    implements this interface, you must document the script languages that the
    connector supports, as well as any supported
    <literal>OperationOptions</literal>.
   </para>

   <section xml:id='ScriptOnResourceApiOp-api-level-rules'>
    <title>ScriptOnResourceApiOp</title>
    <para>
     The contract at the API level is intentionally very loose. Each connector
     decides what script languages it supports, what running a script on a
     target resource actually means, and what script options (if any) the
     connector supports.
    </para>
    <example>
     <title>Implementation of the ScriptOnResource operation, at the API Level</title>
     <programlisting language="java">@Test
public void runScriptOnResourceTest() {
    logger.info("Running RunScriptOnResource Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    builder.setRunAsUser("admin");
    builder.setRunWithPassword(new GuardedString("Passw0rd".toCharArray()));

    final ScriptContextBuilder scriptBuilder = new ScriptContextBuilder("bash", "whoami");

    Object result = facade.runScriptOnResource(scriptBuilder.build(), builder.build());
    Assert.assertEquals(result, "admin");
}    </programlisting>
    </example>
   </section>

   <section xml:id='ScriptOnResourceOp-spi-level-rules'>
    <title>ScriptOnResourceOp</title>
    <para>
     The <literal>scriptOnResource</literal> SPI operation takes the following
     parameters:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>request</literal> - the script and the arguments to be run
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>options</literal> - additional options that control how the
       script is run
      </para>
     </listitem>
    </itemizedlist>
    <para>
     The operation returns the result of the script. The return type must be a
     type that the framework supports for serialization. See the <link
    xlink:href="http://openicf.forgerock.org/apidocs/org/identityconnectors/framework/common/serializer/ObjectSerializerFactory.html">ObjectSerializerFactory</link>
     javadoc for a list of supported return types.
    </para>
    <example>
     <title>Implementation of the ScriptOnResource operation, at the SPI Level</title>
     <programlisting language="java">public Object runScriptOnResource(ScriptContext request, OperationOptions options) {
    try {
        // Execute the script on remote resource
        if (StringUtil.isNotBlank(options.getRunAsUser())) {
            String password = SecurityUtil.decrypt(options.getRunWithPassword());
            // Use these to execute the script with these credentials
            return options.getRunAsUser();
        }
        throw new UnknownHostException("Failed to connect to remote SSH");
    } catch (Throwable e) {
        logger.warn(e, "Failed to execute Script");
        throw ConnectorException.wrap(e);
    }
}    </programlisting>
    </example>
   </section>
  </section>

  <section xml:id='operation-search'>
   <title>Search Operation</title>
   <para>
    The search operation enables the connector to search for objects on the
    target system.
   </para>
   <itemizedlist>
    <para>
     The search operation implementation includes two steps:
    </para>
    <listitem>
     <para>
      Creating a filter translator that translates the specified filter into one
      or more native queries
     </para>
    </listitem>
    <listitem>
     <para>
      Executing the query
     </para>
    </listitem>
   </itemizedlist>
   <para>
    The connector facade calls the <literal>executeQuery</literal> method once
    for each native query that the filter translator produces. If the filter
    translator produces more than one native query, the connector facade merges
    the results from each query and eliminates any duplicates.
   </para>
   <para>
    Note that this implies an in-memory data structure that holds a set of UID
    values. Memory usage, in the event of multiple queries, will be O(N) where N
    is the number of results. It is therefore important that the filter
    translator for the connector implement <literal>OR</literal> operators, if
    possible.
   </para>

   <section xml:id='GetApiOp-api-level-rules'>
    <title>GetApiOp</title>
    <para>
     The <literal>GetApiOp</literal> returns an
     <literal>UnknownUidException</literal> when the Uid does not exist on the
     resource.
    </para>
    <example>
     <title>Implementation of the Get operation, at the API Level</title>
     <programlisting language="java">@Test
public void getObjectTest() {
    logger.info("Running GetObject Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    builder.setAttributesToGet(Name.NAME);
    ConnectorObject co =
            facade.getObject(ObjectClass.ACCOUNT, new Uid(
                    "3f50eca0-f5e9-11e3-a3ac-0800200c9a66"), builder.build());
    Assert.assertEquals(co.getName().getNameValue(), "Foo");
}    </programlisting>
    </example>
   </section>

   <section xml:id='SearchApiOp-api-level-rules'>
    <title>SearchApiOp</title>
    <example>
     <title>Implementation of the Search operation, at the API Level</title>
      <programlisting language="java">@Test
public void searchTest() {
    logger.info("Running Search Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    builder.setPageSize(10);
    final ResultsHandler handler = new ToListResultsHandler();

    SearchResult result =
            facade.search(ObjectClass.ACCOUNT, FilterBuilder.equalTo(new Name("Foo")), handler,
                    builder.build());
    Assert.assertEquals(result.getPagedResultsCookie(), "0");
    Assert.assertEquals(((ToListResultsHandler) handler).getObjects().size(), 1);
}</programlisting>
    </example>
   </section>

   <section xml:id='SearchOp-spi-level-rules'>
    <title>SearchOp</title>
    <example>
     <title>Implementation of the Search operation, at the SPI Level</title>
     <programlisting language="java">public FilterTranslator&lt;String> createFilterTranslator(ObjectClass objectClass,
        OperationOptions options) {
    return new BasicFilterTranslator();
}

public void executeQuery(ObjectClass objectClass, String query, ResultsHandler handler,
        OperationOptions options) {
    final ConnectorObjectBuilder builder = new ConnectorObjectBuilder();
    builder.setUid("3f50eca0-f5e9-11e3-a3ac-0800200c9a66");
    builder.setName("Foo");
    builder.addAttribute(AttributeBuilder.buildEnabled(true));

    for (ConnectorObject connectorObject : CollectionUtil.newSet(builder.build())) {
        if (!handler.handle(connectorObject)) {
            // Stop iterating because the handler stopped processing
            break;
        }
    }
    if (options.getPageSize() != null &amp;&amp; 0 &lt; options.getPageSize()) {
        logger.info("Paged Search was requested");
        ((SearchResultsHandler) handler).handleResult(new SearchResult("0", 0));
    }
}</programlisting>
    </example>
   </section>
  </section>

  <section xml:id='operation-sync'>
   <title>Sync Operation</title>
   <para>
    The sync operation polls the target system for synchronization events, that
    is, native changes to target objects.
   </para>
   <para>
    The operation has two methods:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>sync()</literal> - request synchronization events from the target
      system
     </para>
     <para>
      This method calls the specified handler, once, to pass back each matching
      synchronization event. When the method returns, it will no longer invoke
      the specified handler.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>getLatestSyncToken()</literal> - returns the token corresponding
      to the most recent synchronization event
     </para>
    </listitem>
   </itemizedlist>

   <section xml:id='SyncApiOp-api-level-rules'>
    <title>SyncApiOp</title>
    <example>
     <title>Implementation of the sync operation
      (<literal>getLatestSyncToken()</literal> method), at the API Level</title>
     <programlisting language="java">@Test
public void getLatestSyncTokenTest() {
    logger.info("Running GetLatestSyncToken Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    SyncToken token = facade.getLatestSyncToken(ObjectClass.ACCOUNT);
    Assert.assertEquals(token.getValue(), 10);
}    </programlisting>
     <para>
      The <literal>getLatestSyncToken</literal> method throws an
      <literal>IllegalArgumentException</literal> if the
      <literal>objectClass</literal> is null or invalid.
     </para>
    </example>

    <example>
     <title>Implementation of the sync operation (<literal>sync()</literal>
      method), at the API Level</title>
     <programlisting language="java">@Test
public void syncTest() {
    logger.info("Running Sync Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    builder.setPageSize(10);
    final SyncResultsHandler handler = new SyncResultsHandler() {
        public boolean handle(SyncDelta delta) {
            return false;
        }
    };

    SyncToken token =
            facade.sync(ObjectClass.ACCOUNT, new SyncToken(10), handler, builder.build());
    Assert.assertEquals(token.getValue(), 10);
}    </programlisting>
     <para>
      The <literal>sync</literal> method throws an
      <literal>IllegalArgumentException</literal> if the
      <literal>objectClass</literal> or <literal>handler</literal> is null, or
      if any argument is invalid.
     </para>
    </example>
   </section>

   <section xml:id='SyncOp-spi-level-rules'>
    <title>SyncOp</title>
    <example>
     <title>Implementation of the sync operation at the SPI Level</title>
     <programlisting language="java">public void sync(ObjectClass objectClass, SyncToken token, SyncResultsHandler handler,
        final OperationOptions options) {
    if (ObjectClass.ALL.equals(objectClass)) {
        //
    } else if (ObjectClass.ACCOUNT.equals(objectClass)) {
        final ConnectorObjectBuilder builder = new ConnectorObjectBuilder();
        builder.setUid("3f50eca0-f5e9-11e3-a3ac-0800200c9a66");
        builder.setName("Foo");
        builder.addAttribute(AttributeBuilder.buildEnabled(true));

        final SyncDeltaBuilder deltaBuilder = new SyncDeltaBuilder();
        deltaBuilder.setObject(builder.build());
        deltaBuilder.setDeltaType(SyncDeltaType.CREATE);
        deltaBuilder.setToken(new SyncToken(10));

        for (SyncDelta connectorObject : CollectionUtil.newSet(deltaBuilder.build())) {
            if (!handler.handle(connectorObject)) {
                // Stop iterating because the handler stopped processing
                break;
            }
        }
    } else {
        logger.warn("Sync of type {0} is not supported", configuration.getConnectorMessages()
                .format(objectClass.getDisplayNameKey(), objectClass.getObjectClassValue()));
        throw new UnsupportedOperationException("Sync of type"
                + objectClass.getObjectClassValue() + " is not supported");
    }
    ((SyncTokenResultsHandler) handler).handleResult(new SyncToken(10));
}

public SyncToken getLatestSyncToken(ObjectClass objectClass) {
    if (ObjectClass.ACCOUNT.equals(objectClass)) {
        return new SyncToken(10);
    } else {
        logger.warn("Sync of type {0} is not supported", configuration.getConnectorMessages()
                .format(objectClass.getDisplayNameKey(), objectClass.getObjectClassValue()));
        throw new UnsupportedOperationException("Sync of type"
                + objectClass.getObjectClassValue() + " is not supported");
    }
}    </programlisting>
    </example>
   </section>
  </section>

  <section xml:id='operation-test'>
   <title>Test Operation</title>
   <para>
    The test operation tests the connector configuration. Unlike validation,
    testing a configuration checks that every part of the environment that is
    referred to by the configuration is available.
   </para>
   <para>
    For example, the connector might make a physical connection to the host that
    is specified in the configuration, to check that it exists and that the
    credentials supplied in the configuration are valid.
   </para>
   <para>
    The test operation can be invoked before the configuration has been
    validated, or can validate the configuration before testing it.
   </para>

   <section xml:id='TestApiOp-api-level-rules'>
    <title>TestApiOp</title>
    <para>
     At the API level, the test operation throws a
     <literal>RuntimeException</literal> if the configuration is not valid, or
     if the test fails. Your connector implementation should throw the most
     specific exception available. When no specific exception is available,
     your connector implementation should throw a <literal>ConnectorException</literal>.
    </para>
    <example>
     <title>Implementation of the test operation at the API Level</title>
     <programlisting language="java">@Test
public void testTest() {
    logger.info("Running Test Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    facade.test();
}</programlisting>
    </example>
   </section>

   <section xml:id='TestOp-spi-level-rules'>
    <title>TestOp</title>
    <example>
     <title>Implementation of the test operation at the SPI Level</title>
     <programlisting language="java">public void test() {
    logger.ok("Test works well");
}</programlisting>
    </example>
   </section>
  </section>

  <section xml:id="operation-update">
   <title>Update Operation</title>
   <para>
    If your connector will allow an authorized caller to update (modify or
    replace) objects on the target system, you must implement either the
    update operation, or the <xref linkend="operation-update-attribute-values" />.
    At the API level update operation calls either the
    <literal>UpdateOp</literal> or the <literal>UpdateAttributeValuesOp</literal>,
    depending on what you have implemented.
   </para>
   <para>
    The update operation is somewhat simpler to implement than the
    <xref linkend="operation-update-attribute-values" />, because the update
    attribute values operation must handle any type of update that the caller
    might specify. However a true implementation of the update
    attribute values operation offers better performance and atomicity
    semantics.
   </para>
   <section xml:id='UpdateApiOp-api-level-rules'>
    <title>UpdateApiOp</title>
    <para>
     At the API level, the update operation returns an
     <literal>UnknownUidException</literal> if the Uid does not exist on the
     target system resource and if the connector does not implement the
     <xref linkend="operation-update-attribute-values" /> interface.
    </para>
    <example>
     <title>Implementation of the update operation at the API Level</title>
     <programlisting language="java">@Test
public void updateTest() {
    logger.info("Running Update Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    Set&lt;Attribute> updateAttributes = new HashSet&lt;Attribute>();
    updateAttributes.add(new Name("Foo"));

    Uid uid =
            facade.update(ObjectClass.ACCOUNT, new Uid("Foo"), updateAttributes, builder
                    .build());
    Assert.assertEquals(uid.getUidValue(), "foo");
}</programlisting>
    </example>
   </section>

   <section xml:id='UpdateOp-spi-level-rules'>
    <title>UpdateOp</title>
    <para>
     At the SPI level, the update operation returns an
     <literal>UnknownUidException</literal> if the Uid does not exist on the
     target system.
    </para>
    <example>
     <title>Implementation of the update operation at the SPI Level</title>
     <programlisting language="java">public Uid update(ObjectClass objectClass, Uid uid, Set&lt;Attribute> replaceAttributes,
        OperationOptions options) {
    AttributesAccessor attributesAccessor = new AttributesAccessor(replaceAttributes);
    Name newName = attributesAccessor.getName();
    Uid uidAfterUpdate = uid;
    if (newName != null) {
        logger.info("Rename the object {0}:{1} to {2}", objectClass.getObjectClassValue(), uid
                .getUidValue(), newName.getNameValue());
        uidAfterUpdate = new Uid(newName.getNameValue().toLowerCase());
    }

    if (ObjectClass.ACCOUNT.equals(objectClass)) {

    } else if (ObjectClass.GROUP.is(objectClass.getObjectClassValue())) {
        if (attributesAccessor.hasAttribute("members")) {
            throw new InvalidAttributeValueException(
                    "Requested to update a read only attribute");
        }
    } else {
        logger.warn("Update of type {0} is not supported", configuration.getConnectorMessages()
                .format(objectClass.getDisplayNameKey(), objectClass.getObjectClassValue()));
        throw new UnsupportedOperationException("Update of type"
                + objectClass.getObjectClassValue() + " is not supported");
    }
    return uidAfterUpdate;
}    </programlisting>
    </example>
   </section>
  </section>

  <section xml:id='operation-update-attribute-values'>
   <title>Update Attribute Values Operation</title>
   <para>
    The update attribute values operation is an advanced implementation of the
    update operation. You should implement this operation if you want your
    connector to offer better performance and atomicity for the following
    methods:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>UpdateApiOp.addAttributeValues(ObjectClass, Uid, Set, OperationOptions)</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>UpdateApiOp.removeAttributeValues(ObjectClass, Uid, Set, OperationOptions)</literal>
     </para>
    </listitem>
   </itemizedlist>
    <example>
     <title>Implementation of the add and remove attribute values methods, at
      the API Level</title>
     <programlisting language="java">@Test
public void addAttributeValuesTest() {
    logger.info("Running AddAttributeValues Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    Set&lt;Attribute> updateAttributes = new HashSet&lt;Attribute>();
    // add 'group2' to existing groups
    updateAttributes.add(AttributeBuilder.build(PredefinedAttributes.GROUPS_NAME, "group2"));

    Uid uid =
            facade.addAttributeValues(ObjectClass.ACCOUNT, new Uid("Foo"), updateAttributes,
                    builder.build());
    Assert.assertEquals(uid.getUidValue(), "foo");
}

@Test
public void removeAttributeValuesTest() {
    logger.info("Running RemoveAttributeValues Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    Set&lt;Attribute> updateAttributes = new HashSet&lt;Attribute>();
    // remove 'group2' from existing groups
    updateAttributes.add(AttributeBuilder.build(PredefinedAttributes.GROUPS_NAME, "group2"));

    Uid uid =
            facade.removeAttributeValues(ObjectClass.ACCOUNT, new Uid("Foo"), updateAttributes,
                    builder.build());
    Assert.assertEquals(uid.getUidValue(), "foo");
}</programlisting>
   </example>

   <section xml:id='UpdateAttributeValuesOp-spi-level-rules'>
    <title>UpdateAttributeValuesOp</title>
    <para>
     At the SPI level, the update attribute values operation returns an
     <literal>UnknownUidException</literal> when the Uid does not exist on the
     resource.
    </para>
    <example>
     <title>Implementation of the update attribute values operation, at the SPI
      Level</title>
     <programlisting language="java">public Uid addAttributeValues(ObjectClass objectClass, Uid uid, Set&lt;Attribute> valuesToAdd,
        OperationOptions options) {
    return uid;
}

public Uid removeAttributeValues(ObjectClass objectClass, Uid uid,
        Set&lt;Attribute> valuesToRemove, OperationOptions options) {
    return uid;
}    </programlisting>
    </example>
   </section>
  </section>

  <section xml:id='operation-validate'>
    <title>Validate Operation</title>
    <para>
     The validate operation is implemented only at the API level. This operation
     validates the connector configuration. A valid configuration is one that is
     <emphasis>ready to be used</emphasis> by the connector.
    </para>
    <itemizedlist>
     <para>
      A configuration that is <emphasis>ready</emphasis>, has the following
      characteristics:
     </para>
     <listitem>
      <para>
       It is complete, that is all required properties are present and have
       values
      </para>
     </listitem>
     <listitem>
      <para>
       All property values are well-formed, that is, they are in the expected
       range and have the expected format
      </para>
     </listitem>
    </itemizedlist>

    <section xml:id='ValidateApiOp-api-level-rules'>
     <title>ValidateApiOp</title>
      <para>
       The validate operation returns a <literal>ConfigurationException</literal>
       in the following situations:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         The Framework version is not compatible with the connector
        </para>
       </listitem>
       <listitem>
        <para>
         The connector does not have the required attributes in
         <literal>MANIFEST.MF</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         The <literal>ConfigurationProperties</literal> cannot be merged into
         the configuration
        </para>
       </listitem>
      </itemizedlist>
      <example>
       <title>Implementation of the valid operation, at the API Level</title>
       <programlisting language="java">@Test
public void ValidateTest() {
    logger.info("Running Validate Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    facade.validate();
}</programlisting>
     </example>
    </section>
   </section>
  </section>

  <section xml:id='commons-exceptions'>
   <title>Common Exceptions</title>
   <para>
    The following sections describe the commonly used exceptions that can be
    thrown, depending on the operation.
   </para>

   <section xml:id='AlreadyExistsException-exception'>
    <title>AlreadyExistsException</title>
    <para>
     The <literal>AlreadyExistsException</literal> is thrown if a create
     operation attempts to create an object that exists prior to the method
     execution, or if an update operation attempts to rename an object to that
     exists prior to the method execution.
    </para>
   </section>

   <section xml:id='ConfigurationException-exception'>
    <title>ConfigurationException</title>
    <para>
     A <literal>ConfigurationException</literal> is thrown if a configuration
     problem is encountered when the connector bundles are loaded. A
     <literal>ConfigurationException</literal> can also be thrown during
     validation operations in the SPI.
    </para>
   </section>

   <section xml:id='ConnectionBrokenException-exception'>
    <title>ConnectionBrokenException</title>
    <para>
     A <literal>ConnectionBrokenException</literal> is thrown when a connection
     to a target resource instance fails during an operation. An instance of the
     <literal>ConnectionBrokenException</literal> generally wraps the native
     exception (or describes the native error) that is returned by the target
     resource.
    </para>
   </section>

   <section xml:id='ConnectionFailedException-exception'>
    <title>ConnectionFailedException</title>
    <para>
     A <literal>ConnectionFailedException</literal> is thrown when a connector
     cannot reach the target resource. An instance of the
     <literal>ConnectionFailedException</literal> generally wraps the native
     exception (or describes the native error) that is returned by the target
     resource.
    </para>
   </section>

   <section xml:id='ConnectorException-exception'>
    <title>ConnectorException</title>
    <para>
     This is the base exception for the connector framework. The framework only
     throws exceptions that extend <literal>ConnectorException</literal>.
    </para>
   </section>

   <section xml:id='ConnectorIOException-exception'>
    <title>ConnectorIOException</title>
    <para>
     This is the base exception for all Input-Output (I/O-related) exceptions,
     including instance connection failure, socket error and so forth.
    </para>
   </section>

   <section xml:id='ConnectorSecurityException-exception'>
    <title>ConnectorSecurityException</title>
    <para>
     This is the base exception for all security-related exceptions.
    </para>
   </section>

   <section xml:id='InvalidAttributeValueException-exception'>
    <title>InvalidAttributeValueException</title>
    <para>
     An <literal>InvalidAttributeValueException</literal> is thrown when an
     attempt is made to add to an attribute a value that conflicts with the
     attribute's schema definition. This might happen, for example, in the
     following situations:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       The connector attempts to add an attribute with no value when the
       attribute is required to have at least one value
      </para>
     </listitem>
     <listitem>
      <para>
       The connector attempts to add more than one value to a single
       valued-attribute
      </para>
     </listitem>
     <listitem>
      <para>
       The connector attempts to add a value that conflicts with the attribute
       type
      </para>
     </listitem>
     <listitem>
      <para>
       The connector attempts to add a value that conflicts with the attribute
       syntax
      </para>
     </listitem>
    </itemizedlist>
   </section>

   <section xml:id='InvalidCredentialException-exception'>
    <title>InvalidCredentialException</title>
    <para>
     An <literal>InvalidCredentialException</literal> indicates that user
     authentication has failed. This exception is thrown by the connector when
     authentication fails, and when the specific reason for the failure is not
     known. For example, the connector might throw this exception if a user has
     entered an incorrect password, or username.
    </para>
   </section>

   <section xml:id='InvalidPasswordException-exception'>
    <title>InvalidPasswordException</title>
    <para>
     An <literal>InvalidPasswordException</literal> is thrown when a password
     credential is invalid.
    </para>
   </section>

   <section xml:id='OperationTimeoutException-exception'>
    <title>OperationTimeoutException</title>
    <para>
     An <literal>OperationTimeoutException</literal> is thrown when an operation
     times out. The framework cancels an operation when the corresponding method
     has been executing for longer than the limit specified in
     <literal>APIConfiguration</literal>.
    </para>
   </section>

   <section xml:id='PasswordExpiredException-exception'>
    <title>PasswordExpiredException</title>
    <para>
     A <literal>PasswordExpiredException</literal> indicates that a user
     password has expired. This exception is thrown by the connector when it
     can determine that a password has expired. For example, after successfully
     authenticating a user, the connector might determine that the user's
     password has expired. The connector throws this exception to notify the
     application, which can then take the appropriate steps to notify the user.
    </para>
   </section>

   <section xml:id='PermissionDeniedException-exception'>
    <title>PermissionDeniedException</title>
    <para>
     A <literal>PermissionDeniedException</literal> is thrown when the target
     resource will not allow a connector to perform a particular operation. An
     instance of the <literal>PermissionDeniedException</literal> generally
     describes a native error (or wraps a native exception) that is returned by
     the target resource.
    </para>
   </section>

   <section xml:id='PreconditionFailedException-exception'>
    <title>PreconditionFailedException</title>
    <para>
     A <literal>PreconditionFailedException</literal> is thrown to indicate that
     a resource's current version does not match the version provided. This
     exception is equivalent to the HTTP status: <literal>412 Precondition
     Failed</literal>.
    </para>
   </section>

   <section xml:id='PreconditionRequiredException-exception'>
    <title>PreconditionRequiredException</title>
    <para>
     A <literal>PreconditionRequiredException</literal> is thrown to indicate
     that a resource requires a version, but that no version was supplied in the
     request. This exception is equivalent to the HTTP status: <literal>428
     Precondition Required</literal>.
    </para>
   </section>

   <section xml:id='RetryableException-exception'>
    <title>RetryableException</title>
    <para>
     A <literal>RetryableException</literal> indicates that the failure might be
     temporary, and that retrying the same request might succeed in the future.
    </para>
   </section>

   <section xml:id='UnknownUidException-exception'>
    <title>UnknownUidException</title>
    <para>
     An <literal>UnknownUidException</literal> is thrown when a Uid that is
     specified as input to a connector operation identifies no object on the
     target resource. When you implement the <literal>AuthenticateOp</literal>,
     your connector can throw this exception if it is unable to locate the
     account necessary to perform authentication.
    </para>
   </section>

   <section xml:id='NullPointerException-exception'>
    <title>NullPointerException (c# NullReferenceException)</title>
    <para>
     TODO
    </para>
   </section>

   <section xml:id='UnsupportedOperationException-exception'>
    <title>UnsupportedOperationException (c# NotSupportedException)</title>
    <para>
     TODO
    </para>
   </section>

   <section xml:id='IllegalStateException-exception'>
    <title>IllegalStateException (c# InvalidOperationException)</title>
    <para>
     TODO
    </para>
   </section>

   <section xml:id='IllegalArgumentException-exception'>
    <title>IllegalArgumentException (c# ArgumentException)</title>
    <para>
     TODO
    </para>
   </section>
  </section>

 <section xml:id='generic-exception-rules'>
  <title>Generic Rules</title>
  <para>These rules are common for all API or SPI level operations:</para>

  <section xml:id='framework-api-level-rules'>
   <title>Framework (API Level) Exception Rules</title>
   <variablelist>
    <varlistentry>
     <term>IllegalArgumentException or NullPointerException</term>
     <listitem>
      <para>
       Thrown when the ObjectClass is null or the name is blank.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>OperationTimeoutException</term>
     <listitem>
      <para>
       Thrown when the operation timed out.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>ConnectionFailedException</term>
     <listitem>
      <para>
       Thrown if any problem occurs with the connector server connection.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>UnsupportedOperationException</term>
     <listitem>
      <para>
       Thrown if the connector does not implement the required interface.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>ConnectorIOException</term>
     <listitem>
      <para>
       Thrown if the connector failed to initialize a remote connection due to a
       SocketException.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>ConnectorException</term>
     <listitem>
      <para>
       Thrown in the following situations:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         The connector failed to initiate the remote connection due to a
         <literal>SocketException</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         An unexpected request was sent to the remote connector server
        </para>
       </listitem>
       <listitem>
        <para>
         An unexpected response was received from the remote connector server
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>InvalidCredentialException</term>
     <listitem>
      <para>
       Thrown if the remote framework key is invalid
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

            <para>
                The pool exceptions may be interesting to IDM.
                <itemizedlist>
                    <listitem>
                        <para>ConnectorException</para>
                        <para>If the pool has no more available Connector after the {@link
                            ObjectPoolConfiguration#maxWait} time.</para>
                    </listitem>
                    <listitem>
                        <para>IllegalStateException</para>
                        <para>If Object pool already shutdown.</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>

  <section xml:id='framework-spi-level-rules'>
   <title>Connector (SPI Level) Exception Rules</title>
   <variablelist>
    <varlistentry>
     <term>InvalidAttributeValueException</term>
     <listitem>
      <para>
       Thrown when single-valued attribute has multiple values
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IllegalArgumentException</term>
     <listitem>
      <para>
       Thrown when the value of the <literal>__PASSWORD__</literal> or the
       <literal>__CURRENT_PASSWORD__</literal> attribute is not a
       <literal>GuardedString</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IllegalStateException</term>
     <listitem>
      <para>
       Thrown when the <literal>Attribute</literal> name is blank
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>PermissionDeniedException</term>
     <listitem>
      <para>
       Thrown when the target resource will not allow a specific operation to be
       performed. An instance of the <literal>PermissionDeniedException</literal>
       generally describes a native error that is returned by (or wraps a native
       exception that is thrown by) the target resource.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>ConnectorIOException, ConnectionBrokenException, ConnectionFailedException</term>
     <listitem>
      <para>
       Thrown when any problem occurs with the connection to the target resource
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>PreconditionFailedException</term>
     <listitem>
      <para>
       Thrown when the current version of the resource object does not match the
       version provided by the connector
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>PreconditionRequiredException</term>
     <listitem>
      <para>
       Thrown when a resource object requires a version, but no version was
       supplied in the <literal>Uid#getRevision</literal>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </section>
 </section>
</chapter>