<?xml version="1.0" encoding="UTF-8"?>
<!--
  ! CCPL HEADER START
  !
  ! This work is licensed under the Creative Commons
  ! Attribution-NonCommercial-NoDerivs 3.0 Unported License.
  ! To view a copy of this license, visit
  ! http://creativecommons.org/licenses/by-nc-nd/3.0/
  ! or send a letter to Creative Commons, 444 Castro Street,
  ! Suite 900, Mountain View, California, 94041, USA.
  !
  ! You can also obtain a copy of the license at
  ! legal-notices/CC-BY-NC-ND.txt.
  ! See the License for the specific language governing permissions
  ! and limitations under the License.
  !
  ! If applicable, add the following below this CCPL HEADER, with the fields
  ! enclosed by brackets "[]" replaced with your own identifying information:
  !      Portions Copyright [yyyy] [name of copyright owner]
  !
  ! CCPL HEADER END
  !
  !      Copyright 2012-2015 ForgeRock AS
  !
-->
<chapter xml:id='chap-openicf-api'
 xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en'
 xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
 xsi:schemaLocation='http://docbook.org/ns/docbook http://docbook.org/xml/5.0/xsd/docbook.xsd'
 xmlns:xlink='http://www.w3.org/1999/xlink'
 xmlns:xinclude='http://www.w3.org/2001/XInclude'>
 <title>Using the OpenICF API</title>
 <para>
  This chapter describes how to use the OpenICF API, which enables you to call
  OpenICF connector implementations from your application. The chapter
  demonstrates creating a connector facade, required for applications to access
  connectors, and then how to call the various OpenICF operations from your
  application.
 </para>

 <section xml:id="create-connector-facade">
  <title>Creating the Connector Facade</title>
  <para>
   Applications access the connector API through a
   <literal>ConnectorFacade</literal> class, and interact with the connector
   through a <literal>ConnectorFacade</literal> instance.
  </para>
  <orderedlist>
   <para>
    The following steps describe how to create a
    <literal>ConnectorFacade</literal> in your application.
   </para>
   <listitem>
    <para>
     Create a <literal>ConnectorInfoManager</literal> and a
     <literal>ConnectorKey</literal> for the connector.
    </para>
    <para>
     The <literal>ConnectorKey</literal> uniquely identifies the Connector
     instance. The <literal>ConnectorKey</literal> class takes a
     <literal>bundleName</literal> (the name of the Connector bundle), a
     <literal>bundleVersion</literal> (the version of the Connector bundle) and
     a connectorName (the name of the Connector)
    </para>
    <para>
     The <literal>ConnectorInfoManager</literal> retrieves a
     <literal>ConnectorInfo</literal> object for the connector.
    </para>
<programlisting language="java">
ConnectorInfoManagerFactory fact = ConnectorInfoManagerFactory.getInstance();
File bundleDirectory = new File("/connectorDir/bundles/myconnector");
URL url = IOUtil.makeURL(bundleDirectory,
        "/dist/org.identityconnectors.myconnector-1.0.jar");
ConnectorInfoManager manager = fact.getLocalManager(url);
ConnectorKey key = new ConnectorKey("org.identityconnectors.myconnector",
        "1.0", "MyConnector");
</programlisting>
   </listitem>
   <listitem>
    <para>
     Use the connector info manager and the connector key to create a
     <literal>ConnectorInfo</literal> instance.
    </para>
    <programlisting language="java">
ConnectorInfo info = manager.findConnectorInfo(key);
    </programlisting>
   </listitem>
   <listitem>
    <para>
     From the <literal>ConnectorInfo</literal> object, create the default
     <literal>APIConfiguration</literal>.
    </para>
<programlisting language="java">
APIConfiguration apiConfig = info.createDefaultAPIConfiguration();
</programlisting>
   </listitem>
   <listitem>
    <para>
     Use the default <literal>APIConfiguration</literal> to retrieve the
     <literal>ConfigurationProperties</literal>.
    </para>
<programlisting language="java">
ConfigurationProperties properties = apiConfig.getConfigurationProperties();</programlisting>
   </listitem>
   <listitem>
    <para>
     Optionally, print out the list of configuration properties.
    </para>
    <programlisting language="java">
List&lt;String&gt; propertyNames = properties.getPropertyNames();
for(String propName : propertyNames) {
    ConfigurationProperty prop = properties.getProperty(propName);
    System.out.println("Property Name: " + prop.getName() +
            "\tProperty Type: " + prop.getType());
}   </programlisting>
   </listitem>
   <listitem>
    <para>
     Set all of the <literal>ConfigurationProperties</literal> that you need for
     the connector, using <literal>setPropertyValue()</literal>.
    </para>
    <programlisting language="java">
properties.setPropertyValue("host", SAMPLE_HOST);
properties.setPropertyValue("adminName", SAMPLE_ADMIN);
properties.setPropertyValue("adminPassword", SAMPLE_PASSWORD);
properties.setPropertyValue("useSSL", false);  </programlisting>
   </listitem>
   <listitem>
    <para>
     Use the <literal>newInstance()</literal> method of the
     <literal>ConnectorFacadeFactory</literal> to create a new instance of the
     connector.
    </para>
    <programlisting language="java">
ConnectorFacade conn = ConnectorFacadeFactory.getInstance()
        .newInstance(apiConfig); </programlisting>
   </listitem>
   <listitem>
    <para>
     Validate that you have set up the connector configuration correctly.
    </para>
    <programlisting language="java">
conn.validate(); </programlisting>
   </listitem>
   <listitem>
    <para>
     Use the new connector with the supported operations (described in the
     following sections).
    </para>
    <programlisting language="java">
conn.[authenticate|create|update|delete|search|...]  </programlisting>
   </listitem>
  </orderedlist>
 </section>

 <section xml:id="getting-supported-operations">
  <title>Checking Which Operations Are Supported</title>
  <para>
   Different connectors support different subsets of the overall set of
   operations provided by OpenICF. When your connector is ready to use, you can
   use the <literal>ConnectorFacade</literal> to determine which operations your
   connector supports.
  </para>
  <para>
   The quickest way to check whether an operation is supported is to determine
   whether that specific operation is part of the set of supported operations.
   The following sample test checks if the <literal>CreateApiOp</literal> is
   supported:
  </para>
  <programlisting language="java">
Set&lt;Class&lt; ? extends APIOperation>> ops = conn.getSupportedOperations();
return ops.contains(CreateApiOp.class);</programlisting>
  <para>
   Note that a connector might support a particular operation, only for specific
   object classes. For example, the connector might allow you to
   <emphasis>create</emphasis> a user, but not a group. A more thorough check
   to determine whether the connector supports an operation therefore involves
   checking the object class on which you plan to perform the operation, as
   shown in the following example.
  </para>
  <programlisting language="java">
Schema schema = conn.schema();
Set&lt;ObjectClassInfo> objectClasses = schema.getObjectClassInfo();
Set&lt;ObjectClassInfo> ocinfos = schema
        .getSupportedObjectClassesByOperation(CreateApiOp.class);

for(ObjectClassInfo oci : objectClasses) {
    // Check that the operation is supported for your object class.
    if (ocinfos.contains(ocinfo)) {
        // object class is supported
    }
}</programlisting>
 </section>

 <section xml:id="checking-schema">
  <title>Checking the Schema</title>
  <para>
   In addition to determining the supported operations for an object class, your
   application can check which attributes are <emphasis>required</emphasis> and
   which attributes are <emphasis>allowed</emphasis> for a particular object
   class. The <literal>ObjectClassInfo</literal> class contains this information
   as a set of <literal>AttributeInfo</literal> objects.
  </para>
  <para>
   The following example shows how to retrieve the attributes for an object
   class.
  </para>
  <programlisting language="java">
Schema schema = conn.schema();
Set&lt;ObjectClassInfo> objectClasses = schema.getObjectClassInfo();
for(ObjectClassInfo oci : objectClasses) {
    Set&lt;AttributeInfo> attributeInfos = oci.getAttributeInfo();
    String type = oci.getType();
    if(ObjectClass.ACCOUNT_NAME.equals(type)) {
        for(AttributeInfo info : attributeInfos) {
            System.out.println(info.toString());
        }
    }
}</programlisting>
 </section>

 <section xml:id="getting-the-object-class">
  <title>Retrieving a List of Object Classes</title>
  <para>
   The following example shows how to retrieve the schema as a list of
   <literal>ObjectClass</literal> objects, from the
   <literal>ObjectClassInfo</literal> class.
  </para>
  <programlisting language="java">
ObjectClass objectClass = new ObjectClass(objectClassInfo.getType());</programlisting>
 </section>

 <section xml:id="creating-objects">
  <title>Creating Objects</title>
  <para>
   After you have set up the <literal>ConnectorFacade</literal>, checked that
   the operation is supported, and made sure that you can set at least all of
   the required attributes for the object, you can create a new object by using
   the <literal>ConnectorFacade.create()</literal> method.
  </para>
  <para>
   The <literal>ConnectorFacade.create()</literal> method takes the object class
   and the set of attributes as its arguments. The object class specifies the
   type of <literal>ConnectorObject</literal> (account, group, and so forth) to
   create. The attributes describe the connector object (name, password,
   members, and so forth). The object class and the allowed and required
   attributes are identified in the connector schema.
  </para>
  <para>
  The following example shows a code fragment that creates an account.
  </para>
  <programlisting language="java">
Set&lt;Attribute> attrs = new HashSet&lt;Attribute>();
attrs.add(new Name("MyUser"));
attrs.add(AttributeBuilder.buildPassword("secret12"));
attrs.add(AttributeBuilder.build("Company", "Example.COM"));
Uid userUid = conn.create(ObjectClass.ACCOUNT, attrs);</programlisting>
 </section>

 <section xml:id="updating-passwords">
  <title>Updating Passwords</title>
  <para>
   Passwords are a special type of attribute, called an <firstterm>operational
   attribute</firstterm>. Another example of an operational attribute is the
   <literal>enabled</literal> attribute. You create operational attributes by
   using static <literal>AttributeBuilder</literal> methods.
  </para>
  <para>
   The following example shows a code fragment to update the password of the
   account created in the previous example.
  </para>
  <programlisting language="java">
Set&lt;Attribute> attrs = new HashSet&lt;Attribute>();
attrs.add(new Name("MyUser"));
attrs.add(AttributeBuilder.buildPassword("newPassword"));
Uid userUid = conn.update(ObjectClass.ACCOUNT, attrs);</programlisting>
 </section>

 <section xml:id="deleting-objects">
  <title>Deleting Objects</title>
  <para>
   You delete accounts by specifying their object class and
   <literal>Uid</literal>. If the connector supports the search operation for
   accounts, you can look up the UID, by using an attribute value that you know
   already, such as the <literal>username</literal> of the account.
  </para>
  <para>
   The following example deletes an account, based on its
   <literal>username</literal>.
  </para>
  <programlisting language="java">
Uid userUid = findUid(userName);
conn.delete(ObjectClass.ACCOUNT, userUid);</programlisting>
 </section>

 <section xml:id="searching">
  <title>Searching for Objects</title>
  <para>
   If the connector supports searching for your object class, you can use
   the <literal>ConnectorFacade.search()</literal> method. To set up a search,
   create a <literal>Filter</literal> and a <literal>ResultsHandler</literal>.
   The filter determines what to match on the connected resource, and must fit
   the schema for the object class. The following code fragment uses a compound
   filter and a handler to display the results found.
  </para>
  <programlisting language="java">
Filter leftFilter = FilterBuilder.equalTo(AttributeBuilder
        .build("FIRSTNAME", "John"));
Filter rightFilter = FilterBuilder.equalTo(AttributeBuilder
        .build("DEPARTMENT", "Engineering"));
Filter filter = FilterBuilder.and(leftFilter, rightFilter);
final List&lt;ConnectorObject> results = new ArrayList&lt;ConnectorObject>();
ResultsHandler handler = new ResultsHandler() {
    public boolean handle(ConnectorObject obj) {
        results.add(obj);
        return true;
    }
};

conn.search(ObjectClass.ACCOUNT, filter, handler);
for(ConnectorObject obj : results ) {
    System.out.println("Name: " + obj.getName() +
            "\tUID: " + obj.getUid());
}</programlisting>

  <para>
   You can use an operational attribute in the search filter. The following
   example searches for disabled accounts.
  </para>

  <programlisting language="java">
Filter nameFilter = FilterBuilder.startsWith(new Name("John"));
Filter enabledFilter = FilterBuilder.equalTo(AttributeBuilder
        .buildEnabled(false));     // Account is disabled.
Filter filter = FilterBuilder.or(nameFilter, enabledFilter);
final List&lt;ConnectorObject> results = new ArrayList&lt;ConnectorObject>();
ResultsHandler handler = new ResultsHandler() {
    public boolean handle(ConnectorObject obj) {
        results.add(obj);
        return true;
    }
};

conn.search(ObjectClass.ACCOUNT, filter, handler);
for(ConnectorObject obj : results ) {
    System.out.println("Name: " + obj.getName() +
            "\tUID: " + obj.getUid());
}</programlisting>
 </section>

</chapter>
